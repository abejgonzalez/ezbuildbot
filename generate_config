#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  generate_config
#  Generate a master.cfg for buildbot based on a JSON/YAML configuration.

import ast
import astor
import copy
import sys
from functools import reduce
from typing import cast, Optional

from ezbuildbot_config import *

# 0.5 is not compatible with Python >3.5
astor_version = astor.__version__.split(".")
assert int(astor_version[0]) >= 0 and int(
    astor_version[1]) > 5, "requires astor version 0.6 or higher"


class GetFunction(ast.NodeVisitor):
    def __init__(self, function: str) -> None:
        """
        Get the named function from the AST.
        """
        self.function = function
        self.result: Optional[ast.FunctionDef] = None

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        if node.name == self.function:
            self.result = node


def get_function(name: str, module: ast.Module) -> ast.FunctionDef:
    """
    Get the given function from the given module.
    """
    visitor = GetFunction(name)
    visitor.visit(module)
    if visitor.result is not None:
        return visitor.result
    else:
        raise ValueError(f"Function {name} not found")

class SubstituteVariables(ast.NodeTransformer):
    """
    Transformation to replace a set of variable references to another.
    """
    def __init__(self, mapping: Dict[str, str]) -> None:
        self.mapping: Dict[str, str] = mapping

    def visit_Name(self, node: ast.Name) -> Any:
        # Replace id if a mapping for it exists.
        return ast.Name(id=self.mapping.get(node.id, node.id), ctx=node.ctx)

class SubstituteVariablesExpr(ast.NodeTransformer):
    """
    Transformation to replace a set of variable references with arbitrary
    expressions.
    """
    def __init__(self, mapping: Dict[str, ast.expr]) -> None:
        for v in mapping.values():
            assert isinstance(v, ast.expr)
        self.mapping: Dict[str, ast.expr] = mapping

    def visit_Name(self, node: ast.Name) -> Any:
        # If mapping exists, return it; otherwise return the same node.
        return self.mapping.get(node.id, node)

def check_signature(sig: str, func: ast.FunctionDef) -> None:
    """
    Check that the signature of the function matches the one given as a
    string.
    """
    reference_def = ast.parse(sig).body[0]
    assert isinstance(reference_def, ast.FunctionDef)

    if astor.to_source(func.args) != astor.to_source(reference_def.args):
        raise ValueError(f"The function signature is incorrect - got {astor.to_source(func.args)} instead of {astor.to_source(reference_def.args)}")

def generate_step(factory: ast.expr, step: Tuple[str, str], module: ast.Module) -> List[ast.stmt]:
    assert isinstance(factory, ast.expr)
    assert isinstance(step, tuple)

    template_function: ast.FunctionDef = get_function("template_create_step", module)

    check_signature("def template_create_step(factory, name: str, command: str) -> None: pass", template_function)

    # Substitute name and command
    # deepcopy functions since the transformer will modify the source tree
    substituted_func = SubstituteVariablesExpr({
        "factory": factory,
        "name": ast.Str(step[0]),
        "command": ast.Str(step[1])
    }).visit(copy.deepcopy(template_function))

    # Return body of method
    body = substituted_func.body
    for n in body:
        assert isinstance(n, ast.stmt)
    return body

def generate_builder(builder: Builder, module: ast.Module):
    template_function: ast.FunctionDef = get_function("template_create_builder", module)

    check_signature("def template_create_builder(name: str, repourl: str, workernames: List[str]): pass", template_function)

    class ReplaceSteps(ast.NodeTransformer):
        def visit_Expr(self, node: ast.Expr) -> Any:
            # We are trying to replace something like
            # Expr(value=Call(func=Name(id='template_create_step_placeholder')))
            if not isinstance(node.value, ast.Call):
                return node
            call = cast(ast.Call, node.value)

            if not isinstance(call.func, ast.Name):
                return node
            func = cast(ast.Name, call.func)

            if not func.id == "template_create_step_placeholder":
                return node

            # Get the first arg as it is the factory name
            factory = call.args[0]

            # Generate steps
            return reduce(lambda x, y: x + y, map(lambda step: generate_step(factory, step, module), builder.steps))

    substituted_func = ReplaceSteps().visit(copy.deepcopy(template_function))

    return substituted_func

class MyPass(ast.NodeTransformer):
    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:
        print(astor.to_source(node))
        print(repr(node.name))
        return node

# ~ tree = MyPass().visit(tree)


def parse_template_tree() -> ast.Module:
    with open("master-template.py", 'r') as f:
        template_str = str(f.read())

    tree = ast.parse(template_str)
    return tree


def main(args) -> int:
    # Load template
    tree = parse_template_tree()

    # Load config
    config = BuildbotConfig.from_filename(args[1])

    # Generate new methods
    print(astor.to_source(generate_builder(config.builders[0], tree)))

    # Substitute dummy methods
    

    # Remove templates

    # ~ print(astor.to_source(tree, indent_with="  "))
    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))

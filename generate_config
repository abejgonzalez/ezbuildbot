#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  generate_config
#  Generate a master.cfg for buildbot based on a JSON/YAML configuration.

import ast
import astor
import copy
import sys
from functools import reduce
from typing import cast, Optional

from ezbuildbot_config import *

# 0.5 is not compatible with Python >3.5
astor_version = astor.__version__.split(".")
assert int(astor_version[0]) >= 0 and int(
    astor_version[1]) > 5, "requires astor version 0.6 or higher"


class GetFunction(ast.NodeVisitor):
    def __init__(self, function: str) -> None:
        """
        Get the named function from the AST.
        """
        self.function = function
        self.result: Optional[ast.FunctionDef] = None

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        if node.name == self.function:
            self.result = node


def get_function(name: str, module: ast.Module) -> ast.FunctionDef:
    """
    Get the given function from the given module.
    """
    visitor = GetFunction(name)
    visitor.visit(module)
    if visitor.result is not None:
        return visitor.result
    else:
        raise ValueError(f"Function {name} not found")


def parse_const_from_object(obj: Any) -> ast.expr:
    """
    Parse a single Python constant into an expr.
    e.g. "15" or "[1, 2, 3]"
    """
    body = ast.parse(repr(obj)).body
    assert len(body) == 1
    assert isinstance(body[0], ast.Expr)
    return body[0].value


def parse_statement(stmt: str) -> ast.stmt:
    """
    Parse a single Python statement.
    e.g. "x = 15" or "y += [1, 2, 3]"
    """
    body = ast.parse(stmt).body
    assert len(body) == 1
    assert isinstance(body[0], ast.stmt)
    return body[0]


def sanitize_name(name: str) -> str:
    """
    Sanitize the given name so that it can be a Python identifier.
    """
    # No empty names
    if name == "":
        return "empty_"

    # No dashes
    name = name.replace('-', '_')

    # No leading digits
    if name.isdigit() or name[0].isdigit():
        return "_" + name

    return name


class SubstituteVariables(ast.NodeTransformer):
    """
    Transformation to replace a set of variable references to another.
    """

    def __init__(self, mapping: Dict[str, str]) -> None:
        self.mapping: Dict[str, str] = mapping

    def visit_Name(self, node: ast.Name) -> Any:
        # Replace id if a mapping for it exists.
        return ast.Name(id=self.mapping.get(node.id, node.id), ctx=node.ctx)


class SubstituteVariablesExpr(ast.NodeTransformer):
    """
    Transformation to replace a set of variable references with arbitrary
    expressions.
    """

    def __init__(self, mapping: Dict[str, ast.expr]) -> None:
        for v in mapping.values():
            assert isinstance(v, ast.expr)
        self.mapping: Dict[str, ast.expr] = mapping

    def visit_Name(self, node: ast.Name) -> Any:
        # If mapping exists, return it; otherwise return the same node.
        return self.mapping.get(node.id, node)


def check_signature(sig: str, func: ast.FunctionDef) -> None:
    """
    Check that the signature of the function matches the one given as a
    string.
    """
    reference_def = ast.parse(sig).body[0]
    assert isinstance(reference_def, ast.FunctionDef)

    if astor.to_source(func.args) != astor.to_source(reference_def.args):
        raise ValueError(
            f"The function signature is incorrect - got {astor.to_source(func.args)} instead of {astor.to_source(reference_def.args)}")


def generate_step(factory: ast.expr, step: Tuple[str, str], module: ast.Module) -> List[ast.stmt]:
    assert isinstance(factory, ast.expr)
    assert isinstance(step, tuple)

    template_function: ast.FunctionDef = get_function(
        "template_create_step", module)

    check_signature(
        "def template_create_step(factory, name: str, command: str) -> None: pass", template_function)

    # Substitute name and command
    # deepcopy functions since the transformer will modify the source tree
    substituted_func = SubstituteVariablesExpr({
        "factory": factory,
        "name": ast.Str(step[0]),
        "command": ast.Str(step[1])
    }).visit(copy.deepcopy(template_function))

    # Return body of method
    body = substituted_func.body
    for n in body:
        assert isinstance(n, ast.stmt)
    return body


def generate_builder(builder: Builder, module: ast.Module) -> ast.FunctionDef:
    """
    Return a function that takes no arguments and returns a builder.
    """
    template_function: ast.FunctionDef = get_function(
        "template_create_builder", module)

    check_signature(
        "def template_create_builder(name: str, repourl: str, workernames: List[str]): pass", template_function)

    # TODO(edwardw): replace this
    workernames = ["worker", "names", "here"]

    class ReplaceSteps(ast.NodeTransformer):
        def visit_Expr(self, node: ast.Expr) -> Any:
            # We are trying to replace something like
            # Expr(value=Call(func=Name(id='template_create_step_placeholder')))
            if not isinstance(node.value, ast.Call):
                return node
            call = cast(ast.Call, node.value)

            if not isinstance(call.func, ast.Name):
                return node
            func = cast(ast.Name, call.func)

            if not func.id == "template_create_step_placeholder":
                return node

            # Get the first arg as it is the factory name
            factory = call.args[0]

            # Generate steps
            return reduce(lambda x, y: x + y, map(lambda step: generate_step(factory, step, module), builder.steps))

    substituted_func = ReplaceSteps().visit(copy.deepcopy(template_function))
    # Also replace the variables.
    SubstituteVariablesExpr({
        "name": ast.Str(builder.name),
        "repourl": ast.Str(builder.git_url),
        "workernames": parse_const_from_object(workernames)
    }).visit(substituted_func)

    # Return a new function with no arguments
    return ast.FunctionDef(
        name=f"get_builder_{sanitize_name(builder.name)}",
        args=ast.arguments(args=[], vararg=None, kwonlyargs=[],
                           kwarg=None, defaults=[], kw_defaults=[]),
        body=substituted_func.body,
        decorator_list=[],
        returns=None)


def generate_get_builders(config: BuildbotConfig, module: ast.Module) -> ast.FunctionDef:
    """
    Generate the get_builders() function.
    """
    function: ast.FunctionDef = copy.deepcopy(
        get_function("get_builders", module))

    # Get all the builder functions
    builder_functions = list(
        map(lambda builder: generate_builder(builder, module), config.builders))

    # Create a return expression for an array of these functions
    return_expr = ast.Return(value=ast.List(
        elts=list(map(lambda f: ast.Call(func=ast.Name(id=f.name),
                                     args=[], keywords=[]), builder_functions))
    ))

    # Add new function body
    function.body = builder_functions + [return_expr]

    return function


def parse_template_tree() -> ast.Module:
    with open("master-template.py", 'r') as f:
        template_str = str(f.read())

    tree = ast.parse(template_str)
    return tree


def main(args) -> int:
    # Load template
    tree = parse_template_tree()

    # Load config
    config = BuildbotConfig.from_filename(args[1])

    # Generate new methods
    print(astor.to_source(generate_get_builders(config, tree)))

    # Substitute dummy methods

    # Remove templates

    # ~ print(astor.to_source(tree, indent_with="  "))
    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))
